<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg">
  <link rel="mask-icon" href="/images/favicon.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-fill-left.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"szd0319.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","width":310,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>


<meta name="description" content="万花丛中过，片叶不沾身">
<meta property="og:type" content="website">
<meta property="og:title" content="舞动的灵魂">
<meta property="og:url" content="https://szd0319.github.io/index.html">
<meta property="og:site_name" content="舞动的灵魂">
<meta property="og:description" content="万花丛中过，片叶不沾身">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Silence">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://szd0319.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>

<script>
    (function(){
        if(''){
            if (prompt('加密文，来试试你的运气吧！') !== ''){
                alert('要不要再尝试一次呢~~');
                history.back();
            }
        }
    })();
</script><title>舞动的灵魂</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">舞动的灵魂</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">I am a good man</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Silence"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">Silence</p>
  <div class="site-description" itemprop="description">万花丛中过，片叶不沾身</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:silence@gmail.com" title="E-Mail → mailto:silence@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://jcoffeezph.top/" title="https:&#x2F;&#x2F;jcoffeezph.top&#x2F;" rel="noopener" target="_blank">ForMe</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://qzmvc1.top/" title="https:&#x2F;&#x2F;qzmvc1.top&#x2F;" rel="noopener" target="_blank">QzmVc1</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szd0319.github.io/2023/02/13/%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="万花丛中过，片叶不沾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动的灵魂">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/13/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">面试题</a>
        </h2>

        <div class="post-meta-container">

          <div class="post-meta">
  
	
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-02-13 21:18:08 / 修改时间：22:07:44" itemprop="dateCreated datePublished" datetime="2023-02-13T21:18:08+08:00">2023-02-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h3><ol>
<li><p> var 定义的变量，没有块的概念，可以跨块访问，不能跨函数访问</p>
</li>
<li><p> let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</p>
</li>
<li><p> const 用来定义常量，使用时必须初始化，只能在块作用域里访问，而且不能修改</p>
</li>
</ol>
<hr>
<h3 id="为什么要-promise-或是异步"><a href="#为什么要-promise-或是异步" class="headerlink" title="为什么要 promise 或是异步"></a>为什么要 promise 或是异步</h3><p>解决多层回调问题（回调地狱）。</p>
<hr>
<h3 id="什么是-axios"><a href="#什么是-axios" class="headerlink" title="什么是 axios"></a>什么是 axios</h3><p>axios是基于promise用于浏览器和node.js的http客户端。</p>
<p>axios主要用于向后台发起请求，还有在请求中做更多的可控功能。</p>
<hr>
<h3 id="axios、ajax、fetch-三者的区别"><a href="#axios、ajax、fetch-三者的区别" class="headerlink" title="axios、ajax、fetch 三者的区别"></a>axios、ajax、fetch 三者的区别</h3><p>（1）      ajax隶属于原始js，核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。</p>
<p>（2）      Fetch是基于promise设计的，它不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p>
<p>（3）      axios不是原生JS的，需要进行安装，它可以在客户端使用，也可以在nodejs端使用。Axios也可以在请求和响应阶段进行拦截。同样也是基于promise对象的。</p>
<hr>
<h3 id="CDN-原理"><a href="#CDN-原理" class="headerlink" title="CDN 原理"></a>CDN 原理</h3><p>CDN 的基本原理是广泛采用各种缓存服务器,将这些缓存服务器分布到用户访问相对集中的地区或网络中,在用户访问网站时,利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上,由缓存服务器直接响应用户请求。</p>
<hr>
<h3 id="CDN-获取最近节点资源的算法是什么"><a href="#CDN-获取最近节点资源的算法是什么" class="headerlink" title="CDN 获取最近节点资源的算法是什么"></a>CDN 获取最近节点资源的算法是什么</h3><p>DNS分地区解析</p>
<hr>
<h3 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h3><p>    TCP：面向连接，三次握手，四次挥手；稳定；面向字节流</p>
<p>    UDP：面向无连接；不稳定；面向报文</p>
<hr>
<h3 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h3><p><strong>302</strong>：暂时重定向</p>
<p><strong>304</strong>：表示页面未更新</p>
<p><strong>400 Bad Request</strong>：表示请求报文中存在语法错误</p>
<p><strong>403 Forbidden</strong>：服务器拒绝该次访问（访问权限出现问题）</p>
<p><strong>404 Not Found</strong>：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用</p>
<p><strong>500 Inter Server Error</strong>：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时</p>
<p><strong>501</strong>：服务器不具有请求功能</p>
<p><strong>502</strong>：网关错误</p>
<p><strong>503 Server Unavailable</strong>：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求</p>
<p><strong>504</strong>：网关超时</p>
<hr>
<h3 id="js-依赖模块"><a href="#js-依赖模块" class="headerlink" title="js 依赖模块"></a>js 依赖模块</h3><p>Import require</p>
<hr>
<h3 id="画几何图形的技术有哪些"><a href="#画几何图形的技术有哪些" class="headerlink" title="画几何图形的技术有哪些"></a>画几何图形的技术有哪些</h3><p>css，canvas，svg</p>
<hr>
<h3 id="http-头信息"><a href="#http-头信息" class="headerlink" title="http 头信息"></a>http 头信息</h3><p>（1）      Accept：告诉WEB服务器自己接受什么介质类型</p>
<p>（2）      Accept-Charset：浏览器申明自己接收的字符集</p>
<p>（3）      Cache-Control：控制缓存</p>
<p>（4）      Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）</p>
<hr>
<h3 id="Web-缓存机制"><a href="#Web-缓存机制" class="headerlink" title="Web 缓存机制"></a>Web 缓存机制</h3><p>1.浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response<br>header及该请求的返回时间一并缓存；</p>
<p>2.下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求</p>
<p>3.服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；</p>
<p>4.如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200。</p>
<hr>
<h3 id="Get-和-post区别"><a href="#Get-和-post区别" class="headerlink" title="Get 和 post区别"></a>Get 和 post区别</h3><p>（1）Get是从服务器上获得数据，而Post则是向服务器传递数据的。</p>
<p>（2）Get是不安全的，很可能你的一些操作会被第三方看到，而Post的所有操作多用户来说是不可见的。</p>
<p>（3）Get 传输的数据量小，主要是因为它受约于 URL 长度的限制，而 Post 可以传输大量的数据，所以我们在传文件的时候会用 Post。</p>
<p>（4）Get限制 From 表单的数据集的值必须为 ASCLL 字符，而 Post 支持整个 ISO10646 字符集。</p>
<hr>
<h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h3><p>概念：如果 “协议 + 域名 + 端口号” 均相同，就是同域，否则是跨域。</p>
<p>解决方法：</p>
<p>（1）      CORS请求：它允许浏览器向声明了 CORS 的跨域服务器，发出 XMLHttpRequest 请求。</p>
<p>（2）      JSONP请求：动态添加<script>标签来调用服务器提供的js脚本。</p>
<p> JSONP请求，缺点是仅支持<strong>GET</strong>请求，CORS比JSONP更强大，支持所有类型的HTTP请求。</p>
<p>（3）  postMessage：如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。window.postMessage方法允许跨窗口通信，不论这两个窗口是否同源。postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。</p>
<p>（4）  WebSocket：Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。</p>
<p>（5） 修改document.domain跨子域：两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。例如把domain属性的值设置为“xxx.com” ，那么”aaa.xxx.com”和”bbb.xxx.com”就可以进行通信了。</p>
<hr>
<h3 id="事件模型和事件代理（事件委托）"><a href="#事件模型和事件代理（事件委托）" class="headerlink" title="事件模型和事件代理（事件委托）"></a>事件模型和事件代理（事件委托）</h3><p>事件模型：是指一个事件发生后，会在子元素和父元素之间传播。</p>
<p>事件代理：事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件。</p>
<hr>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<p>举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p>
<p>可以减少 Dom 的操作次数，减少内存，从而提高性能。</p>
<p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p>
<p>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。</p>
<p>事件冒泡：从被触发事件逐层向上触发父级事件。</p>
<p>事件捕获：从被触发事件逐层向下触发子级事件。</p>
<p>事件冒泡和事件捕获可以通过 addEventListener(触发事件的动作，回调函数，布尔值) 函数实现：第三个参数为默认值 false 是事件冒泡；为 true 是事件捕获。</p>
<hr>
<h3 id="使元素消失的方法有哪些"><a href="#使元素消失的方法有哪些" class="headerlink" title="使元素消失的方法有哪些"></a>使元素消失的方法有哪些</h3><p>1、<code>opacity：0</code>，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的</p>
<p>2、<code>visibility：hidden</code>，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</p>
<p>3、 <code>display：none</code>，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉</p>
<hr>
<h3 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call  apply  bind 区别"></a>call  apply  bind 区别</h3><p>call，apply，bind 这三个方法其实都是继承自 Function.prototype 的。</p>
<p>（1）函数实例的 call 方法，可以指定该函数内部 this 的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。并且会立即执行该函数。</p>
<p>call() 方法可以传递两个参数。第一个参数是指定函数内部中 this 的指向（也就是函数执行时所在的作用域），第二个参数是函数调用时需要传递的参数。</p>
<p>第一个参数是必须的，可以是 null，undefined，this，但是不能为空。设置为 null，undefined，this 表明函数 keith 此时处于全局作用域。</p>
<p>（2）apply 方法的作用与 call 方法类似，也是改变 this 指向（函数执行时所在的作用域），然后在指定的作用域中，调用该函数。同时也会立即执行该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keith</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keith.apply(<span class="literal">null</span>, [<span class="number">2</span>, <span class="number">3</span>]);  <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用： 求数组中的最大值：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, a));</span><br></pre></td></tr></table></figure>

<p> </p>
<p>（3）bind 方法用于指定函数内部的 this 指向（执行时所在的作用域），然后返回一个新函数。bind 方法并非立即执行一个函数。</p>
<p>总结：</p>
<p>a：第一个参数都是指定函数内部中 this 的指向（函数执行时所在的作用域），然后根据指定的作用域，调用该函数。</p>
<p>b：都可以在函数调用时传递参数。call，bind 方法需要直接传入，而 apply 方法需要以数组的形式传入。</p>
<p>c：call，apply 方法是在调用之后立即执行函数，而 bind 方法没有立即执行，需要将函数再执行一遍。有点闭包的味道。</p>
<hr>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>响应式，双向数据绑定，即MVVM。是指数据层（Model）-视图层（View）-数据视图（ViewModel）的响应式框架。它包括：</p>
<p>1.修改View层，Model对应数据发生变化。</p>
<p>2.Model数据变化，不需要查找DOM，直接更新View</p>
<hr>
<h3 id="v-if-和-v-show-的区别"><a href="#v-if-和-v-show-的区别" class="headerlink" title="v-if 和 v-show 的区别"></a>v-if 和 v-show 的区别</h3><p>v-if 的原理是根据判断条件来动态的进行增删 DOM 元素，条件为真进行渲染，为假不渲染。</p>
<p>v-show 是根据判断条件来动态的进行显示和隐藏元素，它总是渲染 DOM 元素。</p>
<p>频繁的进行增删 DOM 操作会影响页面加载速度和性能。</p>
<hr>
<h3 id="多页应用与单页应用"><a href="#多页应用与单页应用" class="headerlink" title="多页应用与单页应用"></a>多页应用与单页应用</h3><p>（1）多页应用</p>
<p>概念：每一次页面跳转的时候，后台服务器都会给返回一个新的 html 文档，这种类型的网站也就是多页网站，也叫做多页应用。</p>
<p>特点：首屏时间快、SEO 效果好、页面切换慢</p>
<p>A. 首屏时间叫做页面首个屏幕的内容展现的时间，当我们访问页面的时候，服务器返回一个html，页面就会展示出来，这个过程只经历了一个 HTTP 请求，所以页面展示的速度非常快。</p>
<p>B. 搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别 html 内容的，而我们每个页面所有的内容都放在 Html 中，所以这种多页应用，seo 排名效果好。</p>
<p>C. 因为每次跳转都需要发出一个 http 请求，如果网络比较慢，在页面之间来回跳转时，就会发现明显的卡顿。</p>
<p>（2）单页应用</p>
<p>概念：第一次进入页面的时候会请求一个 html 文件，刷新清除一下，切换到其他组件，此时路径也相应变化，但是并没有新的 html 文件请求，页面内容也变化了。</p>
<p>特点：页面切换快、首屏时间稍慢、SEO 差</p>
<p>A. 页面每次切换跳转时，并不需要做 html 文件的请求，这样就节约了很多 http 发送时延，我们在切换页面的时候速度很快。</p>
<p>B. 单页应用的首屏时间慢，首屏时需要请求一次 html，同时还要发送一次 js 请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。</p>
<p>C. SEO 效果差，因为搜索引擎只认识 html 里的内容，不认识js的内容，而单页应用的内容都是靠 js 渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。</p>
<br/>

<p>可通过服务器端渲染技术（<strong><strong>SSR</strong></strong>）解决单页应用的缺点。</p>
<p>Vue 属于单页应用</p>
<hr>
<h3 id="首屏时间慢的优化方案"><a href="#首屏时间慢的优化方案" class="headerlink" title="首屏时间慢的优化方案"></a>首屏时间慢的优化方案</h3><p>（1）使用CDN 资源，减小服务器压力</p>
<p>（2）路由懒加载：import 、require.ensure</p>
<p>（3）图片懒加载：为了减少服务器压力，优先加载可视区域的内容，其他部分等进入了可视域再加载，从而提高性能。</p>
<p>（4）按需加载第三方资源（组件库）</p>
<hr>
<h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>为了减少服务器压力，优先加载可视区域的内容，其他部分等进入了可视域再加载，从而提高性能。</p>
<p>原理：</p>
<p>一张图片就是一个 img 标签，浏览器是否发起请求图片是根据的 src 属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给 src 赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给 src 赋值。</p>
<p>实现：</p>
<ol>
<li>加载loading图片：在 html 中 src 中存放的是伪图片（同一张图片），data-src 中存放的是真实图片的地址。<br>2.判断哪些图片要加载【重点】：根据可视区域判断<br>3.隐形加载图片：不在可视区域的图片加载的是伪图片<br>4.替换真图片：当图片进入可视区域时，加载真图片替换伪图片</li>
</ol>
<hr>
<h3 id="localStorage，Cookie-和-sessionStorage-区别"><a href="#localStorage，Cookie-和-sessionStorage-区别" class="headerlink" title="localStorage，Cookie 和 sessionStorage 区别"></a>localStorage，Cookie 和 sessionStorage 区别</h3><p>localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。</p>
<p>（1）localStorage 生命周期是永久，这意味着除非用户显示在浏览器提供的 UI 上清除 localStorage 信息，否则这些信息将永远存在；sessionStorage 生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过 sessionStorage 存储的数据也就被清空了。</p>
<p>（2）浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。</p>
<p>（3）cookie 的数据被请求头携带在浏览器和服务器之间传递，localStorage 的数据只保存在本地；cookie 保存数据大小不超过 4K，而 localStorage 要大得多，可以达到 5M 甚至更大；cookie 数据的过期时间由 expires 属性决定，即使浏览器关闭数据也不会消失。</p>
<hr>
<h3 id="input-中如何监听值的变化"><a href="#input-中如何监听值的变化" class="headerlink" title="input  中如何监听值的变化"></a>input  中如何监听值的变化</h3><p>onchange：当内容发生变化且失去焦点时触发。</p>
<p>oninput：内容发生变化时立即触发，但通过js改变值时不触发。</p>
<p>onpropertychange：内容发生变化时立即触发，包括通过js改变值时，IE专用。</p>
<hr>
<h3 id="节流与防抖"><a href="#节流与防抖" class="headerlink" title="节流与防抖"></a>节流与防抖</h3><p>当频繁的触发一个事件时，会很影响性能并容易导致页面卡顿，所以要合并多次请求，通过函数做一个精确操作。这时就会用到函数防抖或者函数节流。</p>
<p>函数节流是：在固定的时间内触发事件，每隔 n 秒触发一次</p>
<p>函数防抖是：当你频繁触发后，n 秒内只执行一次</p>
<hr>
<h3 id="AMD-CMD-CommonJS"><a href="#AMD-CMD-CommonJS" class="headerlink" title="AMD  CMD  CommonJS"></a>AMD  CMD  CommonJS</h3><p>他们都是用于在模块化定义中使用的，AMD、CMD、CommonJs是ES5中提供的模块化编程的方案，import/export是ES6中定义新增的</p>
<p>（1）AMD：RequireJS 是 AMD 的一个实践，采用前置依赖，异步加载。</p>
<p>（2）CMD：SeaJS 是 CMD 的一个实践，采用就近依赖，同步加载。</p>
<p>（3）CommonJS：Nodejs 是 CommonJS 的一个实践，通过 module.exports 导出，通过 require 导入。同步加载。</p>
<hr>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>content（width、height）、padding、border、margin</p>
<p>实际宽度 = width+2<em>padding+2</em>border+2*margin</p>
<p>实际高度 = height+2<em>padding+2</em>border+2*margin</p>
<hr>
<h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><table>
<thead>
<tr>
<th><em><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css3-pr-animation-name.html">animation-name</a></em></th>
<th>指定要绑定到选择器的关键帧的名称</th>
</tr>
</thead>
<tbody><tr>
<td><em><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css3-pr-animation-duration.html">animation-duration</a></em></td>
<td>动画指定需要多少秒或毫秒完成</td>
</tr>
<tr>
<td><em><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css3-pr-animation-timing-function.html">animation-timing-function</a></em></td>
<td>设置动画将如何完成一个周期</td>
</tr>
<tr>
<td><em><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css3-pr-animation-delay.html">animation-delay</a></em></td>
<td>设置动画在启动前的延迟间隔。</td>
</tr>
<tr>
<td><em><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css3-pr-animation-iteration-count.html">animation-iteration-count</a></em></td>
<td>定义动画的播放次数。</td>
</tr>
<tr>
<td><em><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css3-pr-animation-direction.html">animation-direction</a></em></td>
<td>指定是否应该轮流反向播放动画。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css3-pr-animation-fill-mode.html">animation-fill-mode</a></td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。</td>
</tr>
<tr>
<td><em><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css3-pr-animation-play-state.html">animation-play-state</a></em></td>
<td>指定动画是否正在运行或已暂停。</td>
</tr>
</tbody></table>
<hr>
<h3 id="前端常见的攻击方式"><a href="#前端常见的攻击方式" class="headerlink" title="前端常见的攻击方式"></a>前端常见的攻击方式</h3><p>（1）XSS（跨站脚本攻击）</p>
<p>特点：攻击者会往 web 页面嵌入 js 脚本</p>
<p>解决：在 http 请求头中为 cookie 添加 HttpOnly 属性</p>
<p>（2）CSRF（跨站点请求伪造）</p>
<p>特点：攻击者盗用了你的身份，以你的名义发送恶意请求</p>
<p>解决：验证 HTTP Referer 字段（记录了http请求的来源地址）；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p>
<p>（3）Http Heads</p>
<p>特点：http 协议在 head 和 body 之间有一个空行，攻击者会将 js 代码注入到其中</p>
<p>解决：过滤 header 中出现的非法字符</p>
<hr>
<h3 id="SSR（服务器端渲染）"><a href="#SSR（服务器端渲染）" class="headerlink" title="SSR（服务器端渲染）"></a>SSR（服务器端渲染）</h3><p>概念：简单理解是将组件或页面通过服务器生成 html 字符串，再发送到浏览器。</p>
<p>如果一个页面没使用服务渲染，当请求页面时，返回的 body 里为空，之后执行 js 将 html 结构注入到 body 里，结合 css 显示出来；</p>
<p>如果一个页面使用了服务端渲染，当请求页面时，返回的 body 里已经有了首屏的 html 结构，之后结合 css 显示出来。</p>
<p>作用：更利于 SEO；缩短首屏时间。</p>
<hr>
<h3 id="判断活动页面"><a href="#判断活动页面" class="headerlink" title="判断活动页面"></a>判断活动页面</h3><p>概念：活动页面是指当前正在使用、操作的浏览器页面（不包括最小化）。</p>
<p>判断方法：</p>
<p>使用 <code>document.hidden</code> 来判定是否隐藏：返回值为真，则页面隐藏；返回值为假，则页面为活动页。</p>
<hr>
<h3 id="XHR"><a href="#XHR" class="headerlink" title="XHR"></a>XHR</h3><p>XHR 是 XMLHttpRequest 的对象的简称。</p>
<p>（1）创建对象：</p>
<p><code>var xhr = new XMLHttpRequest();</code></p>
<p>（2）发送请求：</p>
<p><code>xhr.open(‘get’, ‘url’,  true);  // 第三个参数指定是否为异步</code></p>
<p><code>send()</code> 方法接收一个参数，即要作为请求主体发送的数据。调用 send() 方法后，请求被分派到服务器。如果是 GET 方法，send() 方法无参数，或参数为 null；如果是 POST 方法，send() 方法的参数为要发送的数据。</p>
<p>（3）接收响应</p>
<p>如果需要接收的是异步响应，这就需要检测 XHR 对象的 readyState 属性，该属性表示请求响应过程的当前活动阶段。这个属性可取的值如下：</p>
<p>0(UNSENT)：未初始化。尚未调用open()方法</p>
<p>1(OPENED)：启动。已经调用open()方法，但尚未调用send()方法</p>
<p>2(HEADERS_RECEIVED)：发送。己经调用send()方法，且接收到头信息</p>
<p>3(LOADING)：接收。已经接收到部分响应主体信息</p>
<p>4(DONE)：完成。已经接收到全部响应数据，而且已经可以在客户端使用了</p>
<hr>
<h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><p>1、正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。</p>
<p>2、正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。</p>
<p>3、正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。</p>
<p>4、正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</p>
<hr>
<h3 id="CSS-选择器的优先级"><a href="#CSS-选择器的优先级" class="headerlink" title="CSS 选择器的优先级"></a>CSS 选择器的优先级</h3><ol>
<li>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</li>
<li>作为style属性写在元素内的样式</li>
<li>id选择器</li>
<li>类选择器</li>
<li>标签选择器</li>
<li>通配符选择器</li>
<li>继承</li>
<li>浏览器默认属性</li>
</ol>
<p>同一级别中后写的会覆盖先写的样式。</p>
<hr>
<h3 id="伪元素，伪类"><a href="#伪元素，伪类" class="headerlink" title="伪元素，伪类"></a>伪元素，伪类</h3><p>css 引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分。</p>
<p>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过 <code>:hover</code> 来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于 dom 树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</p>
<p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过 <code>:before</code> 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p>
<p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。</p>
<hr>
<h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3><p>（1）一共有 8 种：Number、String、Boolean、Null、undefined、object、symbol、bigInt</p>
<p>（2） 基本类型（单类型）： String、Number、boolean、null、undefined。</p>
<p>引用类型：object。里面包含的 function、Array、date</p>
<p>（3）typeof() 输出值：</p>
<table>
<thead>
<tr>
<th>x</th>
<th>typeof(x)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>‘good’</td>
<td>String</td>
<td></td>
</tr>
<tr>
<td>1, 2, 21.3</td>
<td>Number</td>
<td></td>
</tr>
<tr>
<td>true, false</td>
<td>Boolean</td>
<td></td>
</tr>
<tr>
<td>undefined</td>
<td>undefined</td>
<td></td>
</tr>
<tr>
<td>null</td>
<td>Object</td>
<td>不存在的对象</td>
</tr>
<tr>
<td>NaN</td>
<td>Number</td>
<td>Number中的特殊数值</td>
</tr>
<tr>
<td>object</td>
<td>function</td>
<td></td>
</tr>
<tr>
<td>[], {}</td>
<td>object</td>
<td></td>
</tr>
</tbody></table>
<p>（4）null 和 undefined 的区别：</p>
<p>undefined 是没有定义的，null 是定义了但是为空。</p>
<hr>
<h3 id="em-和-rem-的区别"><a href="#em-和-rem-的区别" class="headerlink" title="em 和 rem 的区别"></a>em 和 rem 的区别</h3><p>em：em是一种相对长度单位，相对于自身元素的字号大小，如果没有设置即参照父容器的字号大小或浏览器默认字号大小。</p>
<p>rem: rem是css3的新标准也是一种相对长度单位，其相对于HTML根标签的字号大小。</p>
<hr>
<h3 id="JS-实现深拷贝的方法"><a href="#JS-实现深拷贝的方法" class="headerlink" title="JS 实现深拷贝的方法"></a>JS 实现深拷贝的方法</h3><p>（1）使用递归的方式</p>
<p>（2）通过 JSON 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone2</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> _obj = <span class="built_in">JSON</span>.stringify(obj),</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(_obj);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：Object.assign()、Array.slice()、Arrary.concant() 都不是真正意义上的深拷贝，它们只能实现第一层的深拷贝，而之后的是浅拷贝。如 [1, 2, 3, [4, 5, 6], 7]。</p>
<hr>
<h3 id="margin-塌陷"><a href="#margin-塌陷" class="headerlink" title="margin 塌陷"></a>margin 塌陷</h3><p>在文档流中，父元素的高度默认是被子元素撑开的，也就是说子元素有多高父元素就有多高。但是当子元素设置浮动之后，子元素会完全脱离文档流，此时将会导致子元素无法撑开父元素的高度，导致父元素高度塌陷。</p>
<p>解决方法：</p>
<p>（1）根据BFC的启动条件，在父级元素上加一个overflow：hidden就可以，其他如上条件之一，如果情况合适均可。</p>
<p>（2）给父级元素添加一个边框，就可以解决；如果不希望看到边框，可以将边框的颜色设成背景色即可。</p>
<hr>
<h3 id="v-for-中-key-的作用"><a href="#v-for-中-key-的作用" class="headerlink" title="v-for 中 key 的作用"></a>v-for 中 key 的作用</h3><p>（1）提高渲染性能。当在进行列表渲染的时候，vue会直接对已有的标签进行复用，不会整个的将所有的标签全部重新删除和创建,只会重新渲染数据。</p>
<p>（2）避免数据混乱的情况出现 （如果元素中包含了有临时数据的元素，如果不用key就会产生数据混乱）</p>
<hr>
<h3 id="ajax-优缺点"><a href="#ajax-优缺点" class="headerlink" title="ajax 优缺点"></a>ajax 优缺点</h3><p><strong>优点：</strong></p>
<p>1、提高了性能和速度</p>
<p>减少客户端和服务器之间的流量传输，同时减少了双方响应的时间，响应更快，因此提高了性能和速度。</p>
<p>2、交互性能好</p>
<p>使用ajax，可以开发更快，更具交互性的Web应用程序。</p>
<p>3、异步调用</p>
<p>AJAX对Web服务器进行异步调用。这意味着客户端浏览器在开始渲染之前避免等待所有数据到达。</p>
<p>4、节省带宽</p>
<p>基于Ajax的应用程序使用较少的服务器带宽，因为无需重新加载完整的页面。</p>
<p><strong>缺点：</strong></p>
<p>1、增加了设计和开发时间</p>
<p>2、比构建经典Web应用程序更复杂</p>
<p>3、AJAX应用程序中的安全性较低，因为所有文件都是在客户端下载的。</p>
<p>4、可能出现网络延迟问题</p>
<p>5、禁用JavaScript的浏览器无法使用该应用程序。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szd0319.github.io/2023/02/13/JS/JS%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="万花丛中过，片叶不沾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动的灵魂">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/02/13/JS/JS%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">JS 基础</a>
        </h2>

        <div class="post-meta-container">

          <div class="post-meta">
  
	
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-02-13 21:07:32 / 修改时间：22:08:19" itemprop="dateCreated datePublished" datetime="2023-02-13T21:07:32+08:00">2023-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="JS-数组去重"><a href="#JS-数组去重" class="headerlink" title="JS 数组去重"></a>JS 数组去重</h3><h6 id="利用集合"><a href="#利用集合" class="headerlink" title="利用集合"></a>利用集合</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> new_array = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(new_array) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h6 id="filter-indexOf"><a href="#filter-indexOf" class="headerlink" title="filter + indexOf"></a>filter + indexOf</h6><p>indexOf 返回的始终是元素第一次出现的位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> new_array = arr.filter(<span class="function">(<span class="params">val, idx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(val) === idx</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(new_array) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="JS-垃圾回收机制（GC）"><a href="#JS-垃圾回收机制（GC）" class="headerlink" title="JS 垃圾回收机制（GC）"></a>JS 垃圾回收机制（GC）</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>垃圾回收机制（Garbage Collection)）简称 GC，所谓垃圾回收机制就是<strong>清理内存的方式</strong>。</p>
<p>垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。不再用到的内存，没有及时释放，就叫做<strong>内存泄漏</strong>（memory leak）。</p>
<p>在 JS 中，我们创建变量的时候，JS 引擎会自动给对象分配对应的内存空间，不需要我们手动分配。当代码执行完毕的时候，JS 引擎也会自动地将你的程序，所占用的内存清理掉。正是因为有垃圾回收机制，才导致了开发者有着不用关心内存管理的错误感觉。</p>
<h5 id="内存的分配机制"><a href="#内存的分配机制" class="headerlink" title="内存的分配机制"></a>内存的分配机制</h5><p>JS 数据类型分为两种：</p>
<ul>
<li>基本数据类型</li>
<li>引用数据类型</li>
</ul>
<p>基本数据类型保存在固定的<strong>栈内存</strong>中，可以直接访问它的值。</p>
<p>引用数据类型，其引用地址保存在栈内存中，引用所指向的值保存在<strong>堆内存</strong>中，需要通过引用地址去访问它的值。</p>
<p>存储在栈内存中的基本数据类型的值，可以直接通过操作系统进行处理。</p>
<p>而堆内存中的引用数据类型的值，大小并不确定，因此需要 JS 引擎的垃圾回收机制进行处理。</p>
<h5 id="内存的回收机制"><a href="#内存的回收机制" class="headerlink" title="内存的回收机制"></a>内存的回收机制</h5><p>在浏览器的发展历史上对于垃圾回收有两种解决策略：</p>
<ul>
<li><strong>标记清除法</strong><ul>
<li>从2012年起，所有浏览器都使用了标记清除法。</li>
<li>目前主流浏览器都是使用标记清除式的垃圾回收策略，只不过收集的间隔有所不同。</li>
</ul>
</li>
<li><strong>引用计数法</strong><ul>
<li>JS引擎很早之前使用过这种策略回收内存。</li>
<li>其核心思想为：将不再被引用的对象（零引用）作为垃圾回收，需要提醒的是，这种策略由于存在很多问题，目前逐渐被弃用了。</li>
</ul>
</li>
</ul>
<h6 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h6><p>当变量进入执行环境时，就将这个变量标记为”进入环境”，从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为”离开环境”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//被标记已进入执行环境</span></span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">f1()  <span class="comment">//执行完毕，a，b被标记离开执行环境，内存释放</span></span><br></pre></td></tr></table></figure>

<p>垃圾回收机制在运行的时候会给存储在内存中的所有变量都加上标记（可以是任何标记方式），然后，它会去除掉处在环境中的变量及被环境中的变量引用的变量（闭包）的标记。而在此之后剩下的带有标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后垃圾回收机制到下一个周期运行时，将释放这些变量的内存，回收它们所占用的空间。</p>
<p>通过标记清除之后，剩下没有被释放的对象在内存中的位置是不变的，这就会导致空闲内存是不连续的，这就造成了<strong>内存碎片问题</strong>。</p>
<p>如果之后需要存储一个新的，需要占据较大连续内存空间的对象的时候，就会造成影响。</p>
<h6 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h6><p>它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。</p>
<h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>该策略的处理过程如下：</p>
<ul>
<li>当声明一个引用类型并赋值给变量时，这个值的引用次数初始为1</li>
<li>如果该值又被赋值给另一个变量，引用次数+1</li>
<li>如果该变量被其他值覆盖了，引用次数-1</li>
<li>当这个值引用次数变为0时，说明该值不再被引用，垃圾回收器会在运行时清理释放其内存</li>
</ul>
<p><strong>代码如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">// 引用次数初始化为1</span></span><br><span class="line"><span class="keyword">let</span> b = a <span class="comment">// 引用次数2，即 obj 被 a 和 b 引用</span></span><br><span class="line">a = <span class="literal">null</span> <span class="comment">// 引用次数1</span></span><br><span class="line">b = <span class="literal">null</span> <span class="comment">// 引用次数0，</span></span><br><span class="line">... <span class="comment">// GC回收此引用类型在堆空间中所占的内存</span></span><br></pre></td></tr></table></figure>

<p>但是存在一些问题，例如最常见的是循环引用现象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123; <span class="comment">// fn引用次数为1，因为window.fn = fn，会在window=null即浏览器关闭时回收</span></span><br><span class="line">    <span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">// A: 1</span></span><br><span class="line">    <span class="keyword">let</span> B = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">// B: 1</span></span><br><span class="line">    A.b = B <span class="comment">// B: 2</span></span><br><span class="line">    B.a = A <span class="comment">// A: 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A对象中引用了B，B对象中引用了A，两者引用计数都不为0，永远不会被回收。</span></span><br><span class="line"><span class="comment">// 若执行无限多次fn，那么内存将会被占满，程序宕机</span></span><br><span class="line">fn();</span><br><span class="line"><span class="comment">// 还有就是这种方法需要一个计数器，这个计数器可能要占据很大的位置，因为我们无法知道被引用数量的多少。</span></span><br></pre></td></tr></table></figure>

<p>若是采用标记清除策略则会在 fn 执行完毕后，作用域销毁，将域中的 A 和 B 变量标记为 0以便 GC 回收内存，不会存在这种问题。</p>
<hr>
<h3 id="JS-原型链"><a href="#JS-原型链" class="headerlink" title="JS 原型链"></a>JS 原型链</h3><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。</p>
<h5 id="prototype-与-proto"><a href="#prototype-与-proto" class="headerlink" title="prototype 与 proto"></a>prototype 与 <strong>proto</strong></h5><p><code>prototype</code> （原型）是构造函数才有的，因为 js 的构造函数和一般 function 没有本质区别，所以只有 function 有 prototype 这一属性。</p>
<p><code>__proto__</code> 属性任何对象都有，其指向对象的原型（prototype）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> F();</span><br><span class="line">f.__proto__ === F.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h5><p>凡是通过 <code>new Function()</code> 创建的都是函数对象。</p>
<p>一般来说，对象只有 <code>__proto__</code> 属性，但是函数对象既有 <code>__proto__</code> 属性，也有 <code>prototype</code> 属性。</p>
<p>函数对象有 Function、Object、Array、Date、String、自定义函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>);   <span class="comment">//function  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>);   <span class="comment">//function  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>);   <span class="comment">//function  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>);   <span class="comment">//function  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>);   <span class="comment">//function  </span></span><br></pre></td></tr></table></figure>

<h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><p>原型对象即 <code>XXX.prototype</code>。</p>
<p>原型对象是包含特定类型的所有实例共享的属性和方法。原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法。</p>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">F.prototype.name = <span class="string">&quot;silence&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f1 = <span class="keyword">new</span> F();</span><br><span class="line"><span class="keyword">const</span> f2 = <span class="keyword">new</span> F();</span><br><span class="line">f2.name = <span class="string">&quot;qzmvc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f1.name, f2.name) <span class="comment">// &quot;silence&quot; &quot;qzmvc&quot;</span></span><br></pre></td></tr></table></figure>

<p>一般来说，原型对象的类型都是 object，但是 <code>Function.prototype</code> 是个例外，它是原型对象，却又是函数对象，作为一个函数对象，它又没有 prototype 属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// 特殊 function  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.__proto__) <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<h5 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h5><p><img src="https://s1.ax1x.com/2023/02/10/pSfotRe.png"></p>
<hr>
<h3 id="箭头函数和普通函数区别"><a href="#箭头函数和普通函数区别" class="headerlink" title="箭头函数和普通函数区别"></a>箭头函数和普通函数区别</h3><ol>
<li><p>箭头函数全都是匿名函数，普通函数可以有匿名函数，也可以有具名函数；</p>
</li>
<li><p>箭头函数不能用于构造函数；</p>
</li>
<li><p>箭头函数没有 arguments 对象；</p>
</li>
<li><p>箭头函数没有原型对象；</p>
</li>
<li><p>this 指向不同。</p>
</li>
</ol>
<hr>
<h3 id="JS-继承方式"><a href="#JS-继承方式" class="headerlink" title="JS 继承方式"></a>JS 继承方式</h3><h5 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h5><blockquote>
<p>让一个构造函数的原型是另一个类型的实例，那么这个构造函数 new 出来的实例就具有该实例的属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>

<p>缺点：对象实例共享所有继承的属性和方法。不能传递参数。</p>
<h5 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, <span class="string">&quot;silence&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 apply() 或 call() 方法在子类构造函数中调用父类构造函数，同时将 this 指向 Son。</p>
<p>优点：解决了原型链继承对象实例共享所有继承的属性和方法以及不能传递参数的问题。</p>
<p>缺点：通过原型添加的属性和方法无法继承。</p>
<h5 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h5><p>所谓组合继承即将原型链继承和构造函数继承组合到一起。</p>
<p>使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sex = <span class="string">&quot;male&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, <span class="string">&quot;silence&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>

<p>优点：解决了原型链继承和构造函数继承造成的影响。</p>
<p>缺点：调用两次父类构造函数。</p>
<h5 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h5><blockquote>
<p><code>Object.create()</code> 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> new_obj = <span class="built_in">Object</span>.create(obj);</span><br><span class="line"><span class="built_in">console</span>.log(new_obj) <span class="comment">// &#123;&#125; | 由于 obj 是 new_obj 的原型，而不是直接赋值，因此这里为空</span></span><br><span class="line"><span class="built_in">console</span>.log(new_obj.name) <span class="comment">// &quot;xxx&quot; | 当在 new_obj 中找不到 name 属性时，就去它的原型中找</span></span><br><span class="line"><span class="built_in">console</span>.log(new_obj.__proto__) <span class="comment">// &#123;name: &quot;xxx&quot;, arr: [1, 2, 3]&#125;</span></span><br><span class="line"></span><br><span class="line">new_obj.arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.arr) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sex = <span class="string">&quot;male&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line"><span class="comment">// 如果未将 Son.prototype.constructor 设置为 Son，</span></span><br><span class="line"><span class="comment">// 它将采用 Parent（父级）的 prototype.constructor。</span></span><br><span class="line">Son.prototype.constructor = Son</span><br></pre></td></tr></table></figure>

<p>缺点：属性中引用类型的值会在对象间共享；子类实例不能向父类传参；只能继承原型上的的属性和方法。</p>
<h5 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sex = <span class="string">&quot;male&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>. <span class="string">&quot;xxx&quot;</span>, <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line">Son.prototype.constructor = Son</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="JS-判断数据类型方法"><a href="#JS-判断数据类型方法" class="headerlink" title="JS 判断数据类型方法"></a>JS 判断数据类型方法</h3><h5 id="使用-typeof"><a href="#使用-typeof" class="headerlink" title="使用 typeof"></a>使用 typeof</h5><p>使用 typeof 能够判断出的数据类型有：</p>
<ul>
<li><p>string</p>
</li>
<li><p>number</p>
</li>
<li><p>boolean</p>
</li>
<li><p>sysmbol</p>
</li>
<li><p>undefined</p>
</li>
<li><p>function</p>
</li>
<li><p>object</p>
</li>
</ul>
<p>基本数据类型中除了 null 都能直接判断出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>引用数据类型只能判断出 function 和 object。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<h5 id="object-prototype-toString-call"><a href="#object-prototype-toString-call" class="headerlink" title="object.prototype.toString.call()"></a>object.prototype.toString.call()</h5><p><code>Object.prototype.toString.call()</code> 将要检查的对象作为第一个参数传递，返回 <code>&quot;[object Type]&quot;</code>，这里的 Type 就是参数的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&quot;&quot;</span>); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">false</span>); <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">12</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// &quot;[object Date]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(f); <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        args = args.concat([...arguments]);</span><br><span class="line">        _this.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="JS-new-一个对象的过程"><a href="#JS-new-一个对象的过程" class="headerlink" title="JS new 一个对象的过程"></a>JS new 一个对象的过程</h3><ol>
<li><p>创建一个空对象；</p>
</li>
<li><p>将该对象连接到对应类的原型；</p>
</li>
<li><p>执行类的构造函数，并将 this 指向该对象，使其拥有类的属性和方法；</p>
</li>
<li><p>返回该对象。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 连接原型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title">constructor</span> = <span class="title">arguments</span>[0];</span><br><span class="line">    obj.__proto__ = <span class="title">constructor</span>.<span class="title">prototype</span>;</span><br><span class="line">    <span class="comment">// 执行构造函数</span></span><br><span class="line">    <span class="title">constructor</span>.<span class="title">applay</span>(<span class="params">obj, [...<span class="built_in">arguments</span>].slice(<span class="number">1</span>)</span>);</span><br><span class="line">    <span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = myNew(F, <span class="string">&quot;silence&quot;</span>, <span class="number">20</span>); <span class="comment">// 等价于 new F(&quot;silence&quot;, 20)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>柯里化，用一句话解释就是，把一个多参数的函数转化为单参数函数的方法。</p>
<p>当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变），然后返回一个新的函数接收剩余的参数，最后返回结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plus(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<p>经过柯里化后这个函数变成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plus</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plus(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><h6 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h6><p>柯里化的函数是分步执行的，第一次调用返回的是一个函数，第二次调用的时候才会进行计算。起到延时计算的作用，通过延时计算求值，称之为惰性求值。</p>
<h6 id="动态生成函数"><a href="#动态生成函数" class="headerlink" title="动态生成函数"></a>动态生成函数</h6><p>看如下示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">level</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>(level + <span class="string">&quot;:&quot;</span> + message)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = log(<span class="string">&quot;INFO&quot;</span>);</span><br><span class="line">info(<span class="string">&quot;xxx&quot;</span>) <span class="comment">// INFO:xxx</span></span><br><span class="line">info(<span class="string">&quot;yyy&quot;</span>) <span class="comment">// INFO:yyy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = log(<span class="string">&quot;DEGUB&quot;</span>); </span><br><span class="line">debug(<span class="string">&quot;xxx&quot;</span>) <span class="comment">// DE<span class="doctag">BUG:</span>xxx</span></span><br><span class="line">debug(<span class="string">&quot;yyy&quot;</span>) <span class="comment">// DE<span class="doctag">BUG:</span>yyy</span></span><br></pre></td></tr></table></figure>

<p>可以看到，如果我们想打印不同级别的日志，且为每条日志固定日志的级别，通过柯里化可以轻松地为当前日志创建便捷函数。</p>
<h5 id="高级柯里化实现"><a href="#高级柯里化实现" class="headerlink" title="高级柯里化实现"></a>高级柯里化实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>curry 函数创建一个函数，该函数接收一个或多个 func 函数的参数，如果 func 所需要的参数都被提供则执行 func 并返回执行的结果，否则继续返回该函数并等待接收剩余的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum);</span><br><span class="line"></span><br><span class="line">alert( curriedSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) ); <span class="comment">// 6，仍然可以被正常调用</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>) ); <span class="comment">// 6，对第一个参数的柯里化</span></span><br><span class="line">alert( curriedSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) ); <span class="comment">// 6，全柯里化</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szd0319.github.io/2023/01/15/css/SVG/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="万花丛中过，片叶不沾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动的灵魂">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/15/css/SVG/" class="post-title-link" itemprop="url">SVG</a>
        </h2>

        <div class="post-meta-container">

          <div class="post-meta">
  
	
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-01-15 21:46:44 / 修改时间：21:51:40" itemprop="dateCreated datePublished" datetime="2023-01-15T21:46:44+08:00">2023-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>HTML体系中，最常用的绘制矢量图的技术是SVG和HTML5新增加的canvas元素。这两种技术都支持绘制矢量图和光栅图。不过canvas更偏重于动画的制作。所以，<code>绘制矢量图</code>的大任落到了SVG身上。</p>
<h3 id="SVG简介"><a href="#SVG简介" class="headerlink" title="SVG简介"></a>SVG简介</h3><p>可缩放矢量图形（Scalable Vector Graphics，简称 SVG）是一种使用 XML 来描述二维图形的语言（SVG 严格遵从 XML 语法）。 SVG 允许三种类型的图形对象：矢量图形形状（例如由直线和曲线组成的路径）、图像和文本。 可以将图形对象（包括文本）分组、样式化、转换和组合到以前呈现的对象中。 SVG 功能集包括嵌套转换、剪切路径、alpha 蒙板和模板对象。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/15/css/SVG/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szd0319.github.io/2023/01/15/css/%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="万花丛中过，片叶不沾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动的灵魂">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/15/css/%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">网格布局</a>
        </h2>

        <div class="post-meta-container">

          <div class="post-meta">
  
	
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-01-15 21:46:36 / 修改时间：21:49:31" itemprop="dateCreated datePublished" datetime="2023-01-15T21:46:36+08:00">2023-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/CSS/" itemprop="url" rel="index"><span itemprop="name">CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是网格布局"><a href="#什么是网格布局" class="headerlink" title="什么是网格布局"></a>什么是网格布局</h3><p>讲到布局，我们就会想到 flex 布局，但 grid 布局更加强大。flex 布局是一维布局，Grid 布局是二维布局。flex 布局一次只能处理一个维度上的元素布局，一行或者一列。Grid 布局是将容器划分成了“行”和“列”，产生了一个个的网格，我们可以将网格元素放在与这些行和列相关的位置上，从而达到我们布局的目的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/15/css/%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szd0319.github.io/2023/01/07/css/%E4%B8%80%E4%BA%9B%E5%8A%A8%E6%95%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="万花丛中过，片叶不沾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动的灵魂">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/07/css/%E4%B8%80%E4%BA%9B%E5%8A%A8%E6%95%88/" class="post-title-link" itemprop="url">一些动效</a>
        </h2>

        <div class="post-meta-container">

          <div class="post-meta">
  
	
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-07 13:43:54" itemprop="dateCreated datePublished" datetime="2023-01-07T13:43:54+08:00">2023-01-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-01-15 21:55:37" itemprop="dateModified" datetime="2023-01-15T21:55:37+08:00">2023-01-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Animation/" itemprop="url" rel="index"><span itemprop="name">Animation</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="波纹效果"><a href="#波纹效果" class="headerlink" title="波纹效果"></a>波纹效果</h3><p>假设 <code>.waves-ripple</code> 类是实现波纹效果的样式，那么它在初始时是一个大小固定的透明的圆，圆心是鼠标点击的地方。在结束时它的直径是目标元素对角线的长度，而且圆心是目标元素的中心。波纹效果就是通过改变它的透明度、伸缩性、位置再加上过渡来实现的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/07/css/%E4%B8%80%E4%BA%9B%E5%8A%A8%E6%95%88/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szd0319.github.io/2023/01/01/JS/js-%E5%85%83%E7%B4%A0%E7%9B%B8%E4%BA%A4%E6%A3%80%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="万花丛中过，片叶不沾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动的灵魂">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/01/01/JS/js-%E5%85%83%E7%B4%A0%E7%9B%B8%E4%BA%A4%E6%A3%80%E6%B5%8B/" class="post-title-link" itemprop="url">js-元素相交检测</a>
        </h2>

        <div class="post-meta-container">

          <div class="post-meta">
  
	
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-01-01 10:53:41 / 修改时间：10:55:46" itemprop="dateCreated datePublished" datetime="2023-01-01T10:53:41+08:00">2023-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Intersection Observer API 提供了一种异步检测目标元素与根元素或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport">viewport</a> 相交情况变化的方法。检测一个元素是否出现在视口中也是它的一个应用。</p>
<p>下面这些情况都需要用到相交检测：</p>
<ul>
<li><p>图片懒加载：当图片滚动到可见时才进行加载；</p>
</li>
<li><p>内容无限滚动：也就是用户滚动到接近内容底部时直接加载更多；</p>
</li>
<li><p>在用户看见某个区域时执行任务或播放动画。</p>
</li>
</ul>
<p>完整 API 见：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">Intersection Observer API - Web API 接口参考 | MDN</a>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/01/JS/js-%E5%85%83%E7%B4%A0%E7%9B%B8%E4%BA%A4%E6%A3%80%E6%B5%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szd0319.github.io/2022/12/18/Vue3/ts%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="万花丛中过，片叶不沾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动的灵魂">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/18/Vue3/ts%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">ts 声明文件</a>
        </h2>

        <div class="post-meta-container">

          <div class="post-meta">
  
	
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-18 12:35:14" itemprop="dateCreated datePublished" datetime="2022-12-18T12:35:14+08:00">2022-12-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2023-01-01 10:50:55" itemprop="dateModified" datetime="2023-01-01T10:50:55+08:00">2023-01-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue3/" itemprop="url" rel="index"><span itemprop="name">Vue3</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="引入-创建声明文件"><a href="#引入-创建声明文件" class="headerlink" title="引入/创建声明文件"></a>引入/创建声明文件</h3><p>在使用 TypeScript 写程序的时候，可能会需要使用到 JavaScript 库，因为历史遗留问题，现在非常多的第三方库依然是用 JavaScript 进行编写，但是大多数情况下，库的所有者已经帮你写好了 TypeScript 声明文件，即 .d.ts 文件。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/12/18/Vue3/ts%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szd0319.github.io/2022/12/18/css/%E6%BB%9A%E5%8A%A8%E5%B1%95%E7%A4%BA%E5%8A%A8%E7%94%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="万花丛中过，片叶不沾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动的灵魂">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/12/18/css/%E6%BB%9A%E5%8A%A8%E5%B1%95%E7%A4%BA%E5%8A%A8%E7%94%BB/" class="post-title-link" itemprop="url">滚动展示动画</a>
        </h2>

        <div class="post-meta-container">

          <div class="post-meta">
  
	
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-12-18 12:29:00 / 修改时间：12:34:13" itemprop="dateCreated datePublished" datetime="2022-12-18T12:29:00+08:00">2022-12-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Animation/" itemprop="url" rel="index"><span itemprop="name">Animation</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如果给向下滚动的页面增加一些细微的动画，这往往能给浏览者带来更好的体验。这往往可以通过触发新进入视口的元素的动画来实现。现在，我们可以通过调用库来更快更方便的实现，wow.js 和 scrollreveal.js 都是不错的选择。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/12/18/css/%E6%BB%9A%E5%8A%A8%E5%B1%95%E7%A4%BA%E5%8A%A8%E7%94%BB/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szd0319.github.io/2022/09/25/uniapp/uni-app%E5%AA%92%E4%BD%93API%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="万花丛中过，片叶不沾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动的灵魂">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/25/uniapp/uni-app%E5%AA%92%E4%BD%93API%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">uni-app 媒体 API 调用异常</a>
        </h2>

        <div class="post-meta-container">

          <div class="post-meta">
  
	
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-25 20:13:44 / 修改时间：20:15:48" itemprop="dateCreated datePublished" datetime="2022-09-25T20:13:44+08:00">2022-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Uni-app/" itemprop="url" rel="index"><span itemprop="name">Uni-app</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在 ios 系统下，若在一个网络请求的回调函数中调用 <code>uni.chooseFile</code>、<code>uni.chooseImage</code> 等 API，那么浏览器将不会弹出文件选择框。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/25/uniapp/uni-app%E5%AA%92%E4%BD%93API%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://szd0319.github.io/2022/09/12/Vue3/axios%E6%8B%A6%E6%88%AA%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="Silence">
      <meta itemprop="description" content="万花丛中过，片叶不沾身">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动的灵魂">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/12/Vue3/axios%E6%8B%A6%E6%88%AA%E5%99%A8/" class="post-title-link" itemprop="url">axios 拦截器</a>
        </h2>

        <div class="post-meta-container">

          <div class="post-meta">
  
	
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-12 19:58:31 / 修改时间：20:00:40" itemprop="dateCreated datePublished" datetime="2022-09-12T19:58:31+08:00">2022-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Vue3/" itemprop="url" rel="index"><span itemprop="name">Vue3</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文主要讲一下 axios 响应拦截器对错误的处理。</p>
<p>先来看一下响应拦截器的格式：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = axios.create();</span><br><span class="line"></span><br><span class="line">request.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/09/12/Vue3/axios%E6%8B%A6%E6%88%AA%E5%99%A8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Silence</span>
</div>


<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>



<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>-->



    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>




  <script async src="/js/cursor/fireworks.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"SZD0319","repo":"SZD0319.github.io","client_id":"edad01c0f99e273ba171","client_secret":"c1c5aa218b3f7b1ef8ea15b13653ff935e425936","admin_user":"SZD0319","distraction_free_mode":false,"proxy":"https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"d1546d731a9f30cc80127d57142a482b"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

  
 
	<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
 

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":-15,"vOffset":-15},"mobile":{"show":true},"react":{"opacity":1},"log":false});</script></body>
</html>

